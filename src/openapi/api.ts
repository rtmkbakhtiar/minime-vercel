/* tslint:disable */
/* eslint-disable */
/**
 * Networkly Chat Rest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdminLogin200Response
 */
export interface AdminLogin200Response {
    /**
     * 
     * @type {string}
     * @memberof AdminLogin200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminLogin200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {object}
     * @memberof AdminLogin200Response
     */
    'pagination'?: object;
    /**
     * 
     * @type {AdminLoginResp}
     * @memberof AdminLogin200Response
     */
    'data'?: AdminLoginResp;
}
/**
 * 
 * @export
 * @interface AdminLoginReq
 */
export interface AdminLoginReq {
    /**
     * 
     * @type {string}
     * @memberof AdminLoginReq
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdminLoginReq
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AdminLoginResp
 */
export interface AdminLoginResp {
    /**
     * 
     * @type {string}
     * @memberof AdminLoginResp
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface BotResp
 */
export interface BotResp {
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'creator_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'bot_alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'short_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'meta_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'meta_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'meta_image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BotResp
     */
    'is_online'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BotResp
     */
    'req_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'welcome_msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotResp
     */
    'created_at'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotResp
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ChatHistoryBotResp
 */
export interface ChatHistoryBotResp {
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryBotResp
     */
    'conv_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryBotResp
     */
    'bot_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryBotResp
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryBotResp
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryBotResp
     */
    'bot_alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryBotResp
     */
    'creator'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryBotResp
     */
    'remaining'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryBotResp
     */
    'latest_msg_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryBotResp
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface CheckUserSubscriptionDetail200Response
 */
export interface CheckUserSubscriptionDetail200Response {
    /**
     * 
     * @type {string}
     * @memberof CheckUserSubscriptionDetail200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckUserSubscriptionDetail200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {CheckUserSubscriptionResp}
     * @memberof CheckUserSubscriptionDetail200Response
     */
    'data'?: CheckUserSubscriptionResp;
}
/**
 * 
 * @export
 * @interface CheckUserSubscriptionResp
 */
export interface CheckUserSubscriptionResp {
    /**
     * Unique identifier for the subscription record
     * @type {number}
     * @memberof CheckUserSubscriptionResp
     */
    'id'?: number;
    /**
     * Code of the profile associated with the subscription
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'profiles_code'?: string;
    /**
     * Amount paid for the subscription
     * @type {number}
     * @memberof CheckUserSubscriptionResp
     */
    'amount'?: number;
    /**
     * Code of the bot
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'bot_code'?: string;
    /**
     * Types of the bot, either bot or main bot
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'bot_types'?: string;
    /**
     * Timestamp when the payment was made
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'payment_date'?: string;
    /**
     * Stripe payment identifier for tracking the transaction
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'stripe_payment_id'?: string;
    /**
     * Stripe payment identifier for tracking the transaction
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'transaction_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CheckUserSubscriptionResp
     */
    'plan'?: number;
    /**
     * 
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'plan_names'?: string;
    /**
     * Status indicating whether the subscription plan is active
     * @type {boolean}
     * @memberof CheckUserSubscriptionResp
     */
    'subscribe_plan_status'?: boolean;
    /**
     * Timestamp indicating when the subscription starts
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'start_time'?: string;
    /**
     * Timestamp indicating when the subscription ends
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'end_time'?: string;
    /**
     * Status of the subscription, e.g., success, pending, failed
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'status'?: string;
    /**
     * Timestamp when the subscription record was created
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'created_at'?: string;
    /**
     * Timestamp when the subscription record was last updated
     * @type {string}
     * @memberof CheckUserSubscriptionResp
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ConvArrResp
 */
export interface ConvArrResp {
    /**
     * 
     * @type {BotResp}
     * @memberof ConvArrResp
     */
    'bot'?: BotResp;
    /**
     * 
     * @type {ConvArrRespConversations}
     * @memberof ConvArrResp
     */
    'conversations'?: ConvArrRespConversations;
}
/**
 * 
 * @export
 * @interface ConvArrRespConversations
 */
export interface ConvArrRespConversations {
    /**
     * 
     * @type {Array<ConvResp>}
     * @memberof ConvArrRespConversations
     */
    'data'?: Array<ConvResp>;
    /**
     * 
     * @type {Pagination}
     * @memberof ConvArrRespConversations
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface ConvResp
 */
export interface ConvResp {
    /**
     * 
     * @type {string}
     * @memberof ConvResp
     */
    'conv_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConvResp
     */
    'creator_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConvResp
     */
    'creator_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConvResp
     */
    'creator_img'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConvResp
     */
    'latest_msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConvResp
     */
    'remaining'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConvResp
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConvResp
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateBotRequest
 */
export interface CreateBotRequest {
    /**
     * bot describe
     * @type {string}
     * @memberof CreateBotRequest
     */
    'q_bot_desc': string;
    /**
     * best describe
     * @type {string}
     * @memberof CreateBotRequest
     */
    'q_best_descibe': string;
    /**
     * 
     * @type {number}
     * @memberof CreateBotRequest
     */
    'q_is_your_own': number;
}
/**
 * 
 * @export
 * @interface CreateSubscribePlan200Response
 */
export interface CreateSubscribePlan200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateSubscribePlan200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSubscribePlan200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {object}
     * @memberof CreateSubscribePlan200Response
     */
    'pagination'?: object;
    /**
     * 
     * @type {SubscribePlanResp}
     * @memberof CreateSubscribePlan200Response
     */
    'data'?: SubscribePlanResp;
}
/**
 * 
 * @export
 * @interface CreateUserSubscription200Response
 */
export interface CreateUserSubscription200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateUserSubscription200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserSubscription200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {object}
     * @memberof CreateUserSubscription200Response
     */
    'pagination'?: object;
    /**
     * 
     * @type {CreateUserSubscription200ResponseData}
     * @memberof CreateUserSubscription200Response
     */
    'data'?: CreateUserSubscription200ResponseData;
}
/**
 * 
 * @export
 * @interface CreateUserSubscription200ResponseData
 */
export interface CreateUserSubscription200ResponseData {
    /**
     * The Stripe payment identifier
     * @type {string}
     * @memberof CreateUserSubscription200ResponseData
     */
    'id'?: string;
    /**
     * Url hosting stripe
     * @type {string}
     * @memberof CreateUserSubscription200ResponseData
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface CreateUserSubscriptionRequest
 */
export interface CreateUserSubscriptionRequest {
    /**
     * Profile code associated with the subscription
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'profiles_code'?: string;
    /**
     * The amount paid for the subscription
     * @type {number}
     * @memberof CreateUserSubscriptionRequest
     */
    'amount'?: number;
    /**
     * Code of the bot
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'bot_code'?: string;
    /**
     * Types of the bot, either bot or main bot
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'bot_types'?: string;
    /**
     * The date and time the payment was made
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'payment_date'?: string;
    /**
     * The Stripe payment identifier
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'stripe_payment_id'?: string;
    /**
     * Payment identifier for tracking the transaction
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'transaction_id'?: string;
    /**
     * When the subscription starts
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'start_time'?: string;
    /**
     * When the subscription ends
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'end_time'?: string;
    /**
     * The current status of the subscription (e.g., active, expired)
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateUserSubscriptionRequest
     */
    'plan'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'plan_names'?: string;
    /**
     * When the subscription was created
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'created_at'?: string;
    /**
     * When the subscription was last updated
     * @type {string}
     * @memberof CreateUserSubscriptionRequest
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface GetAppSetting200Response
 */
export interface GetAppSetting200Response {
    /**
     * 
     * @type {string}
     * @memberof GetAppSetting200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAppSetting200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {GetAppSetting200ResponseData}
     * @memberof GetAppSetting200Response
     */
    'data'?: GetAppSetting200ResponseData;
}
/**
 * 
 * @export
 * @interface GetAppSetting200ResponseData
 */
export interface GetAppSetting200ResponseData {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAppSetting200ResponseData
     */
    'feedbacks'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetBot200Response
 */
export interface GetBot200Response {
    /**
     * 
     * @type {string}
     * @memberof GetBot200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBot200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {Array<BotResp>}
     * @memberof GetBot200Response
     */
    'data'?: Array<BotResp>;
    /**
     * 
     * @type {Pagination}
     * @memberof GetBot200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface GetBotDetail200Response
 */
export interface GetBotDetail200Response {
    /**
     * 
     * @type {string}
     * @memberof GetBotDetail200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBotDetail200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {BotResp}
     * @memberof GetBotDetail200Response
     */
    'data'?: BotResp;
}
/**
 * 
 * @export
 * @interface GetConversation200Response
 */
export interface GetConversation200Response {
    /**
     * 
     * @type {string}
     * @memberof GetConversation200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetConversation200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {ConvArrResp}
     * @memberof GetConversation200Response
     */
    'data'?: ConvArrResp;
}
/**
 * 
 * @export
 * @interface GetConversationDetail200Response
 */
export interface GetConversationDetail200Response {
    /**
     * 
     * @type {string}
     * @memberof GetConversationDetail200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetConversationDetail200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {MsgArrResp}
     * @memberof GetConversationDetail200Response
     */
    'data'?: MsgArrResp;
}
/**
 * 
 * @export
 * @interface GetListChatHistory200Response
 */
export interface GetListChatHistory200Response {
    /**
     * 
     * @type {string}
     * @memberof GetListChatHistory200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListChatHistory200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {Array<ChatHistoryBotResp>}
     * @memberof GetListChatHistory200Response
     */
    'data'?: Array<ChatHistoryBotResp>;
    /**
     * 
     * @type {Pagination}
     * @memberof GetListChatHistory200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface GetListSubscribePlan200Response
 */
export interface GetListSubscribePlan200Response {
    /**
     * 
     * @type {string}
     * @memberof GetListSubscribePlan200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListSubscribePlan200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {Array<SubscribePlanResp>}
     * @memberof GetListSubscribePlan200Response
     */
    'data'?: Array<SubscribePlanResp>;
    /**
     * 
     * @type {Pagination}
     * @memberof GetListSubscribePlan200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface GetListUserSubscription200Response
 */
export interface GetListUserSubscription200Response {
    /**
     * 
     * @type {string}
     * @memberof GetListUserSubscription200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListUserSubscription200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {Array<UserSubscriptionResp>}
     * @memberof GetListUserSubscription200Response
     */
    'data'?: Array<UserSubscriptionResp>;
    /**
     * 
     * @type {Pagination}
     * @memberof GetListUserSubscription200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface GetMainBot200Response
 */
export interface GetMainBot200Response {
    /**
     * 
     * @type {string}
     * @memberof GetMainBot200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMainBot200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {Array<MainBotResp>}
     * @memberof GetMainBot200Response
     */
    'data'?: Array<MainBotResp>;
    /**
     * 
     * @type {Pagination}
     * @memberof GetMainBot200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface GetMainBotDetail200Response
 */
export interface GetMainBotDetail200Response {
    /**
     * 
     * @type {string}
     * @memberof GetMainBotDetail200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMainBotDetail200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {MainBotResp}
     * @memberof GetMainBotDetail200Response
     */
    'data'?: MainBotResp;
}
/**
 * 
 * @export
 * @interface GetSubscribePlanDetail200Response
 */
export interface GetSubscribePlanDetail200Response {
    /**
     * 
     * @type {string}
     * @memberof GetSubscribePlanDetail200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSubscribePlanDetail200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {Array<SubscribePlanResp>}
     * @memberof GetSubscribePlanDetail200Response
     */
    'data'?: Array<SubscribePlanResp>;
}
/**
 * 
 * @export
 * @interface InitConvResp
 */
export interface InitConvResp {
    /**
     * 
     * @type {string}
     * @memberof InitConvResp
     */
    'conv_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof InitConvResp
     */
    'cent_token'?: string;
}
/**
 * 
 * @export
 * @interface InitConversation200Response
 */
export interface InitConversation200Response {
    /**
     * 
     * @type {string}
     * @memberof InitConversation200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof InitConversation200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {InitConvResp}
     * @memberof InitConversation200Response
     */
    'data'?: InitConvResp;
}
/**
 * 
 * @export
 * @interface MainBotResp
 */
export interface MainBotResp {
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'bot_alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'api_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'short_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'meta_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'meta_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'meta_image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MainBotResp
     */
    'is_online'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MainBotResp
     */
    'is_featured_bot'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'welcome_msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainBotResp
     */
    'created_at'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MainBotResp
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MsgArrResp
 */
export interface MsgArrResp {
    /**
     * 
     * @type {ConvResp}
     * @memberof MsgArrResp
     */
    'conversation'?: ConvResp;
    /**
     * 
     * @type {MsgArrRespMessages}
     * @memberof MsgArrResp
     */
    'messages'?: MsgArrRespMessages;
}
/**
 * 
 * @export
 * @interface MsgArrRespMessages
 */
export interface MsgArrRespMessages {
    /**
     * 
     * @type {Array<MsgResp>}
     * @memberof MsgArrRespMessages
     */
    'data'?: Array<MsgResp>;
    /**
     * 
     * @type {Pagination}
     * @memberof MsgArrRespMessages
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface MsgFeebackReq
 */
export interface MsgFeebackReq {
    /**
     * 
     * @type {string}
     * @memberof MsgFeebackReq
     */
    'feedback'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgFeebackReq
     */
    'feedback_desc'?: string;
}
/**
 * 
 * @export
 * @interface MsgRatingReq
 */
export interface MsgRatingReq {
    /**
     * 
     * @type {number}
     * @memberof MsgRatingReq
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface MsgReq
 */
export interface MsgReq {
    /**
     * 
     * @type {string}
     * @memberof MsgReq
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgReq
     */
    'content_type'?: string;
}
/**
 * 
 * @export
 * @interface MsgResp
 */
export interface MsgResp {
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'msg_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'sender_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'sender_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'sender_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'sender_img'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'content_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof MsgResp
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'feedback'?: string;
    /**
     * 
     * @type {string}
     * @memberof MsgResp
     */
    'feedback_desc'?: string;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {string}
     * @memberof Pagination
     */
    'prev'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pagination
     */
    'next'?: string;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'total_bots'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'total_messages'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'total_subsctibe_plans'?: number;
}
/**
 * 
 * @export
 * @interface ProfileResp
 */
export interface ProfileResp {
    /**
     * 
     * @type {string}
     * @memberof ProfileResp
     */
    'f_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileResp
     */
    'l_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileResp
     */
    'email'?: string;
    /**
     * 
     * @type {Array<BotResp>}
     * @memberof ProfileResp
     */
    'bots'?: Array<BotResp>;
}
/**
 * 
 * @export
 * @interface Register200Response
 */
export interface Register200Response {
    /**
     * 
     * @type {string}
     * @memberof Register200Response
     */
    'stat_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Register200Response
     */
    'stat_msg'?: string;
    /**
     * 
     * @type {object}
     * @memberof Register200Response
     */
    'pagination'?: object;
    /**
     * 
     * @type {RegisterResp}
     * @memberof Register200Response
     */
    'data'?: RegisterResp;
}
/**
 * 
 * @export
 * @interface Register400Response
 */
export interface Register400Response {
    /**
     * 
     * @type {string}
     * @memberof Register400Response
     */
    'stat_code': string;
    /**
     * 
     * @type {string}
     * @memberof Register400Response
     */
    'stat_msg': string;
    /**
     * 
     * @type {object}
     * @memberof Register400Response
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface RegisterReq
 */
export interface RegisterReq {
    /**
     * 
     * @type {boolean}
     * @memberof RegisterReq
     */
    'with_bot'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'f_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'l_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'q_best_descibe'?: string;
    /**
     * 
     * @type {number}
     * @memberof RegisterReq
     */
    'q_is_your_own'?: number;
    /**
     * 
     * @type {string}
     * @memberof RegisterReq
     */
    'q_bot_desc'?: string;
}
/**
 * 
 * @export
 * @interface RegisterResp
 */
export interface RegisterResp {
    /**
     * 
     * @type {string}
     * @memberof RegisterResp
     */
    'token'?: string;
    /**
     * 
     * @type {ProfileResp}
     * @memberof RegisterResp
     */
    'profile'?: ProfileResp;
}
/**
 * 
 * @export
 * @interface SubscribePlanReq
 */
export interface SubscribePlanReq {
    /**
     * Code of the bot
     * @type {string}
     * @memberof SubscribePlanReq
     */
    'bot_code': string;
    /**
     * Types of the bot, either bot or main bot
     * @type {string}
     * @memberof SubscribePlanReq
     */
    'bot_types': string;
    /**
     * Name of the subscription plan
     * @type {string}
     * @memberof SubscribePlanReq
     */
    'plan_names': string;
    /**
     * Subscription plan duration
     * @type {number}
     * @memberof SubscribePlanReq
     */
    'plan': number;
    /**
     * Price of the subscription plan
     * @type {number}
     * @memberof SubscribePlanReq
     */
    'price': number;
    /**
     * Status indicating whether the subscription plan is active
     * @type {boolean}
     * @memberof SubscribePlanReq
     */
    'is_active': boolean;
}
/**
 * 
 * @export
 * @interface SubscribePlanResp
 */
export interface SubscribePlanResp {
    /**
     * 
     * @type {number}
     * @memberof SubscribePlanResp
     */
    'id'?: number;
    /**
     * A unique code representing the bot
     * @type {string}
     * @memberof SubscribePlanResp
     */
    'bot_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribePlanResp
     */
    'bot_types'?: string;
    /**
     * Name of the subscription plan
     * @type {string}
     * @memberof SubscribePlanResp
     */
    'plan_names'?: string;
    /**
     * Subscription plan duration in days
     * @type {number}
     * @memberof SubscribePlanResp
     */
    'plan'?: number;
    /**
     * Price of the subscription plan in decimal format
     * @type {number}
     * @memberof SubscribePlanResp
     */
    'price'?: number;
    /**
     * Whether the subscription plan is active
     * @type {boolean}
     * @memberof SubscribePlanResp
     */
    'is_active'?: boolean;
    /**
     * Timestamp when the subscription plan was created
     * @type {string}
     * @memberof SubscribePlanResp
     */
    'created_at'?: string;
    /**
     * Timestamp for the last update of the subscription plan
     * @type {string}
     * @memberof SubscribePlanResp
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface UpdateBotReq
 */
export interface UpdateBotReq {
    /**
     * URL of AI API - ex: https://api.minime.club/sosan
     * @type {string}
     * @memberof UpdateBotReq
     */
    'api_url': string;
    /**
     * avatar image URL
     * @type {string}
     * @memberof UpdateBotReq
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBotReq
     */
    'bot_alias': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBotReq
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBotReq
     */
    'short_description': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBotReq
     */
    'meta_title': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBotReq
     */
    'meta_description': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBotReq
     */
    'meta_image': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateBotReq
     */
    'is_online': boolean;
    /**
     * 0=new, 1=accepted, 2=declined
     * @type {number}
     * @memberof UpdateBotReq
     */
    'req_status': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateBotReq
     */
    'welcome_msg': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBotReq
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateIsActiveSubscribePlanRequest
 */
export interface UpdateIsActiveSubscribePlanRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateIsActiveSubscribePlanRequest
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePriceSubscribePlanRequest
 */
export interface UpdatePriceSubscribePlanRequest {
    /**
     * Price of the subscription plan
     * @type {number}
     * @memberof UpdatePriceSubscribePlanRequest
     */
    'price'?: number;
}
/**
 * 
 * @export
 * @interface UpdateUserSubscriptionRequest
 */
export interface UpdateUserSubscriptionRequest {
    /**
     * Code of the profile associated with the subscription.
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'profiles_code'?: string;
    /**
     * Amount paid for the subscription.
     * @type {number}
     * @memberof UpdateUserSubscriptionRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'bot_code'?: string;
    /**
     * Types of the bot, either bot or main bot
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'bot_types'?: string;
    /**
     * Timestamp when the payment was made.
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'payment_date'?: string;
    /**
     * Stripe payment identifier for tracking the transaction.
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'stripe_payment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'plan_names'?: string;
    /**
     * Payment identifier for tracking the transaction
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'transaction_id'?: string;
    /**
     * Timestamp indicating when the subscription starts.
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'start_time'?: string;
    /**
     * Timestamp indicating when the subscription ends.
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'end_time'?: string;
    /**
     * Status of the subscription, e.g., success, pending, failed.
     * @type {string}
     * @memberof UpdateUserSubscriptionRequest
     */
    'status'?: string;
    /**
     * The plan type associated with the subscription.
     * @type {number}
     * @memberof UpdateUserSubscriptionRequest
     */
    'plan'?: number;
}
/**
 * 
 * @export
 * @interface UserSubscriptionReq
 */
export interface UserSubscriptionReq {
    /**
     * Code of the profile associated with the subscription
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'profiles_code': string;
    /**
     * Amount paid for the subscription
     * @type {number}
     * @memberof UserSubscriptionReq
     */
    'amount': number;
    /**
     * Code of the bot
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'bot_code'?: string;
    /**
     * Types of the bot, either bot or main bot
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'bot_types'?: string;
    /**
     * Timestamp when the payment was made
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'payment_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'plan_names'?: string;
    /**
     * Stripe payment identifier for tracking the transaction
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'stripe_payment_id'?: string;
    /**
     * Payment identifier for tracking the transaction
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'transaction_id'?: string;
    /**
     * Timestamp indicating when the subscription starts
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'start_time'?: string;
    /**
     * Timestamp indicating when the subscription ends
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'end_time'?: string;
    /**
     * Status of the subscription, e.g., success, pending, failed
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof UserSubscriptionReq
     */
    'plan'?: number;
    /**
     * Timestamp when the subscription record was created
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'created_at'?: string;
    /**
     * Timestamp when the subscription record was last updated
     * @type {string}
     * @memberof UserSubscriptionReq
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface UserSubscriptionResp
 */
export interface UserSubscriptionResp {
    /**
     * Unique identifier for the subscription record
     * @type {number}
     * @memberof UserSubscriptionResp
     */
    'id'?: number;
    /**
     * Code of the profile associated with the subscription
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'profiles_code'?: string;
    /**
     * Amount paid for the subscription
     * @type {number}
     * @memberof UserSubscriptionResp
     */
    'amount'?: number;
    /**
     * Code of the bot
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'bot_code'?: string;
    /**
     * Types of the bot, either bot or main bot
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'bot_types'?: string;
    /**
     * Timestamp when the payment was made
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'payment_date'?: string;
    /**
     * Stripe payment identifier for tracking the transaction
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'stripe_payment_id'?: string;
    /**
     * Stripe payment identifier for tracking the transaction
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'transaction_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserSubscriptionResp
     */
    'plan'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'plan_names'?: string;
    /**
     * Timestamp indicating when the subscription starts
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'start_time'?: string;
    /**
     * Timestamp indicating when the subscription ends
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'end_time'?: string;
    /**
     * Status of the subscription, e.g., success, pending, failed
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'status'?: string;
    /**
     * Timestamp when the subscription record was created
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'created_at'?: string;
    /**
     * Timestamp when the subscription record was last updated
     * @type {string}
     * @memberof UserSubscriptionResp
     */
    'updated_at'?: string;
}

/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get application general settings
         * @summary AppSetting
         * @param {string} [group] query string for filter by group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppSetting: async (group?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/app/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
    return {
        /**
         * get application general settings
         * @summary AppSetting
         * @param {string} [group] query string for filter by group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppSetting(group?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAppSetting200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppSetting(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.getAppSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppApiFp(configuration)
    return {
        /**
         * get application general settings
         * @summary AppSetting
         * @param {string} [group] query string for filter by group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppSetting(group?: string, options?: any): AxiosPromise<GetAppSetting200Response> {
            return localVarFp.getAppSetting(group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI {
    /**
     * get application general settings
     * @summary AppSetting
     * @param {string} [group] query string for filter by group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppApi
     */
    public getAppSetting(group?: string, options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).getAppSetting(group, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * admin login to dashboard
         * @summary adminLogin
         * @param {AdminLoginReq} [adminLoginReq] admin login to dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLogin: async (adminLoginReq?: AdminLoginReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminLoginReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * register new user
         * @summary register
         * @param {RegisterReq} [registerReq] register new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerReq?: RegisterReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * admin login to dashboard
         * @summary adminLogin
         * @param {AdminLoginReq} [adminLoginReq] admin login to dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminLogin(adminLoginReq?: AdminLoginReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminLogin(adminLoginReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.adminLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * register new user
         * @summary register
         * @param {RegisterReq} [registerReq] register new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerReq?: RegisterReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * admin login to dashboard
         * @summary adminLogin
         * @param {AdminLoginReq} [adminLoginReq] admin login to dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLogin(adminLoginReq?: AdminLoginReq, options?: any): AxiosPromise<AdminLogin200Response> {
            return localVarFp.adminLogin(adminLoginReq, options).then((request) => request(axios, basePath));
        },
        /**
         * register new user
         * @summary register
         * @param {RegisterReq} [registerReq] register new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerReq?: RegisterReq, options?: any): AxiosPromise<Register200Response> {
            return localVarFp.register(registerReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * admin login to dashboard
     * @summary adminLogin
     * @param {AdminLoginReq} [adminLoginReq] admin login to dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public adminLogin(adminLoginReq?: AdminLoginReq, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).adminLogin(adminLoginReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * register new user
     * @summary register
     * @param {RegisterReq} [registerReq] register new user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(registerReq?: RegisterReq, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BotApi - axios parameter creator
 * @export
 */
export const BotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create bot
         * @summary create bot
         * @param {CreateBotRequest} [createBotRequest] create bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot: async (createBotRequest?: CreateBotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get bots
         * @summary BotManagement
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [status] for filter status bot
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot: async (limit: number, sort?: string, status?: string, next?: string, prev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getBot', 'limit', limit)
            const localVarPath = `/v1/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (prev !== undefined) {
                localVarQueryParameter['prev'] = prev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get bot details
         * @summary BotManagement
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotDetail: async (strCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('getBotDetail', 'strCode', strCode)
            const localVarPath = `/v1/bots/{strCode}`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get list chat history
         * @summary getListChatHistory
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListChatHistory: async (limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getListChatHistory', 'limit', limit)
            const localVarPath = `/v1/bots/chat-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (prev !== undefined) {
                localVarQueryParameter['prev'] = prev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * will be use for activate the bot
         * @summary update bot
         * @param {string} strCode code key for all items
         * @param {UpdateBotReq} [updateBotReq] update bot / activate bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBot: async (strCode: string, updateBotReq?: UpdateBotReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('updateBot', 'strCode', strCode)
            const localVarPath = `/v1/bots/{strCode}`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBotReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotApi - functional programming interface
 * @export
 */
export const BotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotApiAxiosParamCreator(configuration)
    return {
        /**
         * create bot
         * @summary create bot
         * @param {CreateBotRequest} [createBotRequest] create bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBot(createBotRequest?: CreateBotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register400Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBot(createBotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotApi.createBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get bots
         * @summary BotManagement
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [status] for filter status bot
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBot(limit: number, sort?: string, status?: string, next?: string, prev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBot(limit, sort, status, next, prev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotApi.getBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get bot details
         * @summary BotManagement
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotDetail(strCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBotDetail200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotDetail(strCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotApi.getBotDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get list chat history
         * @summary getListChatHistory
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListChatHistory(limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListChatHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListChatHistory(limit, sort, orderBy, next, prev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotApi.getListChatHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * will be use for activate the bot
         * @summary update bot
         * @param {string} strCode code key for all items
         * @param {UpdateBotReq} [updateBotReq] update bot / activate bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBot(strCode: string, updateBotReq?: UpdateBotReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register400Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBot(strCode, updateBotReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotApi.updateBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BotApi - factory interface
 * @export
 */
export const BotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotApiFp(configuration)
    return {
        /**
         * create bot
         * @summary create bot
         * @param {CreateBotRequest} [createBotRequest] create bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot(createBotRequest?: CreateBotRequest, options?: any): AxiosPromise<Register400Response> {
            return localVarFp.createBot(createBotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * get bots
         * @summary BotManagement
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [status] for filter status bot
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(limit: number, sort?: string, status?: string, next?: string, prev?: string, options?: any): AxiosPromise<GetBot200Response> {
            return localVarFp.getBot(limit, sort, status, next, prev, options).then((request) => request(axios, basePath));
        },
        /**
         * get bot details
         * @summary BotManagement
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotDetail(strCode: string, options?: any): AxiosPromise<GetBotDetail200Response> {
            return localVarFp.getBotDetail(strCode, options).then((request) => request(axios, basePath));
        },
        /**
         * get list chat history
         * @summary getListChatHistory
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListChatHistory(limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, options?: any): AxiosPromise<GetListChatHistory200Response> {
            return localVarFp.getListChatHistory(limit, sort, orderBy, next, prev, options).then((request) => request(axios, basePath));
        },
        /**
         * will be use for activate the bot
         * @summary update bot
         * @param {string} strCode code key for all items
         * @param {UpdateBotReq} [updateBotReq] update bot / activate bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBot(strCode: string, updateBotReq?: UpdateBotReq, options?: any): AxiosPromise<Register400Response> {
            return localVarFp.updateBot(strCode, updateBotReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BotApi - object-oriented interface
 * @export
 * @class BotApi
 * @extends {BaseAPI}
 */
export class BotApi extends BaseAPI {
    /**
     * create bot
     * @summary create bot
     * @param {CreateBotRequest} [createBotRequest] create bot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public createBot(createBotRequest?: CreateBotRequest, options?: RawAxiosRequestConfig) {
        return BotApiFp(this.configuration).createBot(createBotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get bots
     * @summary BotManagement
     * @param {number} limit how many items to return at one time (max 100)
     * @param {string} [sort] for sort like desc or asc
     * @param {string} [status] for filter status bot
     * @param {string} [next] parameter next
     * @param {string} [prev] parameter prev
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public getBot(limit: number, sort?: string, status?: string, next?: string, prev?: string, options?: RawAxiosRequestConfig) {
        return BotApiFp(this.configuration).getBot(limit, sort, status, next, prev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get bot details
     * @summary BotManagement
     * @param {string} strCode code key for all items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public getBotDetail(strCode: string, options?: RawAxiosRequestConfig) {
        return BotApiFp(this.configuration).getBotDetail(strCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get list chat history
     * @summary getListChatHistory
     * @param {number} limit how many items to return at one time (max 100)
     * @param {string} [sort] for sort like desc or asc
     * @param {string} [orderBy] order data by name or other default latest_msg_at
     * @param {string} [next] parameter next
     * @param {string} [prev] parameter prev
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public getListChatHistory(limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, options?: RawAxiosRequestConfig) {
        return BotApiFp(this.configuration).getListChatHistory(limit, sort, orderBy, next, prev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * will be use for activate the bot
     * @summary update bot
     * @param {string} strCode code key for all items
     * @param {UpdateBotReq} [updateBotReq] update bot / activate bot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public updateBot(strCode: string, updateBotReq?: UpdateBotReq, options?: RawAxiosRequestConfig) {
        return BotApiFp(this.configuration).updateBot(strCode, updateBotReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConversationApi - axios parameter creator
 * @export
 */
export const ConversationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get conversations of bot
         * @summary get conversation
         * @param {string} strCode code key for all items
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation: async (strCode: string, limit: number, sort?: string, next?: string, prev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('getConversation', 'strCode', strCode)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getConversation', 'limit', limit)
            const localVarPath = `/v1/bots/{strCode}/convs`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (prev !== undefined) {
                localVarQueryParameter['prev'] = prev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get conversation detail (chat)
         * @summary get conversationDetail
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {string} [sort] for sort like desc or asc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationDetail: async (strCode: string, strConvCode: string, limit: number, next?: string, prev?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('getConversationDetail', 'strCode', strCode)
            // verify required parameter 'strConvCode' is not null or undefined
            assertParamExists('getConversationDetail', 'strConvCode', strConvCode)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getConversationDetail', 'limit', limit)
            const localVarPath = `/v1/bots/{strCode}/convs/{strConvCode}/chats`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)))
                .replace(`{${"strConvCode"}}`, encodeURIComponent(String(strConvCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (prev !== undefined) {
                localVarQueryParameter['prev'] = prev;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get conversations of bot
         * @summary initiate convertation
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initConversation: async (strCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('initConversation', 'strCode', strCode)
            const localVarPath = `/v1/bots/{strCode}/init-convs`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * submit hat
         * @summary submitChat
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {MsgReq} [msgReq] submit hat body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitChat: async (strCode: string, strConvCode: string, msgReq?: MsgReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('submitChat', 'strCode', strCode)
            // verify required parameter 'strConvCode' is not null or undefined
            assertParamExists('submitChat', 'strConvCode', strConvCode)
            const localVarPath = `/v1/bots/{strCode}/convs/{strConvCode}/chats`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)))
                .replace(`{${"strConvCode"}}`, encodeURIComponent(String(strConvCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(msgReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * submit feedback for bot answer
         * @summary submitFeedback
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {string} strMsgCode code key for message code
         * @param {MsgFeebackReq} [msgFeebackReq] submit hat body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFeedback: async (strCode: string, strConvCode: string, strMsgCode: string, msgFeebackReq?: MsgFeebackReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('submitFeedback', 'strCode', strCode)
            // verify required parameter 'strConvCode' is not null or undefined
            assertParamExists('submitFeedback', 'strConvCode', strConvCode)
            // verify required parameter 'strMsgCode' is not null or undefined
            assertParamExists('submitFeedback', 'strMsgCode', strMsgCode)
            const localVarPath = `/v1/bots/{strCode}/convs/{strConvCode}/chats/{strMsgCode}/feedback`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)))
                .replace(`{${"strConvCode"}}`, encodeURIComponent(String(strConvCode)))
                .replace(`{${"strMsgCode"}}`, encodeURIComponent(String(strMsgCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(msgFeebackReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * submit Rating for bot answer
         * @summary submitRating
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {string} strMsgCode code key for message code
         * @param {MsgRatingReq} [msgRatingReq] submit hat body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitRating: async (strCode: string, strConvCode: string, strMsgCode: string, msgRatingReq?: MsgRatingReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('submitRating', 'strCode', strCode)
            // verify required parameter 'strConvCode' is not null or undefined
            assertParamExists('submitRating', 'strConvCode', strConvCode)
            // verify required parameter 'strMsgCode' is not null or undefined
            assertParamExists('submitRating', 'strMsgCode', strMsgCode)
            const localVarPath = `/v1/bots/{strCode}/convs/{strConvCode}/chats/{strMsgCode}/rating`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)))
                .replace(`{${"strConvCode"}}`, encodeURIComponent(String(strConvCode)))
                .replace(`{${"strMsgCode"}}`, encodeURIComponent(String(strMsgCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(msgRatingReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationApi - functional programming interface
 * @export
 */
export const ConversationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationApiAxiosParamCreator(configuration)
    return {
        /**
         * get conversations of bot
         * @summary get conversation
         * @param {string} strCode code key for all items
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversation(strCode: string, limit: number, sort?: string, next?: string, prev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConversation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversation(strCode, limit, sort, next, prev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.getConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get conversation detail (chat)
         * @summary get conversationDetail
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {string} [sort] for sort like desc or asc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationDetail(strCode: string, strConvCode: string, limit: number, next?: string, prev?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConversationDetail200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationDetail(strCode, strConvCode, limit, next, prev, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.getConversationDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get conversations of bot
         * @summary initiate convertation
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initConversation(strCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitConversation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initConversation(strCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.initConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * submit hat
         * @summary submitChat
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {MsgReq} [msgReq] submit hat body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitChat(strCode: string, strConvCode: string, msgReq?: MsgReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register400Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitChat(strCode, strConvCode, msgReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.submitChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * submit feedback for bot answer
         * @summary submitFeedback
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {string} strMsgCode code key for message code
         * @param {MsgFeebackReq} [msgFeebackReq] submit hat body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFeedback(strCode: string, strConvCode: string, strMsgCode: string, msgFeebackReq?: MsgFeebackReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register400Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitFeedback(strCode, strConvCode, strMsgCode, msgFeebackReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.submitFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * submit Rating for bot answer
         * @summary submitRating
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {string} strMsgCode code key for message code
         * @param {MsgRatingReq} [msgRatingReq] submit hat body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitRating(strCode: string, strConvCode: string, strMsgCode: string, msgRatingReq?: MsgRatingReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register400Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitRating(strCode, strConvCode, strMsgCode, msgRatingReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.submitRating']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversationApi - factory interface
 * @export
 */
export const ConversationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationApiFp(configuration)
    return {
        /**
         * get conversations of bot
         * @summary get conversation
         * @param {string} strCode code key for all items
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation(strCode: string, limit: number, sort?: string, next?: string, prev?: string, options?: any): AxiosPromise<GetConversation200Response> {
            return localVarFp.getConversation(strCode, limit, sort, next, prev, options).then((request) => request(axios, basePath));
        },
        /**
         * get conversation detail (chat)
         * @summary get conversationDetail
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {string} [sort] for sort like desc or asc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationDetail(strCode: string, strConvCode: string, limit: number, next?: string, prev?: string, sort?: string, options?: any): AxiosPromise<GetConversationDetail200Response> {
            return localVarFp.getConversationDetail(strCode, strConvCode, limit, next, prev, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get conversations of bot
         * @summary initiate convertation
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initConversation(strCode: string, options?: any): AxiosPromise<InitConversation200Response> {
            return localVarFp.initConversation(strCode, options).then((request) => request(axios, basePath));
        },
        /**
         * submit hat
         * @summary submitChat
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {MsgReq} [msgReq] submit hat body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitChat(strCode: string, strConvCode: string, msgReq?: MsgReq, options?: any): AxiosPromise<Register400Response> {
            return localVarFp.submitChat(strCode, strConvCode, msgReq, options).then((request) => request(axios, basePath));
        },
        /**
         * submit feedback for bot answer
         * @summary submitFeedback
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {string} strMsgCode code key for message code
         * @param {MsgFeebackReq} [msgFeebackReq] submit hat body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFeedback(strCode: string, strConvCode: string, strMsgCode: string, msgFeebackReq?: MsgFeebackReq, options?: any): AxiosPromise<Register400Response> {
            return localVarFp.submitFeedback(strCode, strConvCode, strMsgCode, msgFeebackReq, options).then((request) => request(axios, basePath));
        },
        /**
         * submit Rating for bot answer
         * @summary submitRating
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {string} strMsgCode code key for message code
         * @param {MsgRatingReq} [msgRatingReq] submit hat body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitRating(strCode: string, strConvCode: string, strMsgCode: string, msgRatingReq?: MsgRatingReq, options?: any): AxiosPromise<Register400Response> {
            return localVarFp.submitRating(strCode, strConvCode, strMsgCode, msgRatingReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationApi - object-oriented interface
 * @export
 * @class ConversationApi
 * @extends {BaseAPI}
 */
export class ConversationApi extends BaseAPI {
    /**
     * get conversations of bot
     * @summary get conversation
     * @param {string} strCode code key for all items
     * @param {number} limit how many items to return at one time (max 100)
     * @param {string} [sort] for sort like desc or asc
     * @param {string} [next] parameter next
     * @param {string} [prev] parameter prev
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApi
     */
    public getConversation(strCode: string, limit: number, sort?: string, next?: string, prev?: string, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).getConversation(strCode, limit, sort, next, prev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get conversation detail (chat)
     * @summary get conversationDetail
     * @param {string} strCode code key for all items
     * @param {string} strConvCode code key for Conv code
     * @param {number} limit how many items to return at one time (max 100)
     * @param {string} [next] parameter next
     * @param {string} [prev] parameter prev
     * @param {string} [sort] for sort like desc or asc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApi
     */
    public getConversationDetail(strCode: string, strConvCode: string, limit: number, next?: string, prev?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).getConversationDetail(strCode, strConvCode, limit, next, prev, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get conversations of bot
     * @summary initiate convertation
     * @param {string} strCode code key for all items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApi
     */
    public initConversation(strCode: string, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).initConversation(strCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * submit hat
     * @summary submitChat
     * @param {string} strCode code key for all items
     * @param {string} strConvCode code key for Conv code
     * @param {MsgReq} [msgReq] submit hat body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApi
     */
    public submitChat(strCode: string, strConvCode: string, msgReq?: MsgReq, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).submitChat(strCode, strConvCode, msgReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * submit feedback for bot answer
     * @summary submitFeedback
     * @param {string} strCode code key for all items
     * @param {string} strConvCode code key for Conv code
     * @param {string} strMsgCode code key for message code
     * @param {MsgFeebackReq} [msgFeebackReq] submit hat body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApi
     */
    public submitFeedback(strCode: string, strConvCode: string, strMsgCode: string, msgFeebackReq?: MsgFeebackReq, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).submitFeedback(strCode, strConvCode, strMsgCode, msgFeebackReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * submit Rating for bot answer
     * @summary submitRating
     * @param {string} strCode code key for all items
     * @param {string} strConvCode code key for Conv code
     * @param {string} strMsgCode code key for message code
     * @param {MsgRatingReq} [msgRatingReq] submit hat body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApi
     */
    public submitRating(strCode: string, strConvCode: string, strMsgCode: string, msgRatingReq?: MsgRatingReq, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).submitRating(strCode, strConvCode, strMsgCode, msgRatingReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MainBotApi - axios parameter creator
 * @export
 */
export const MainBotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get main bots
         * @summary MainBotManagement
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [isOnline] for filter is online bot 1 or 0
         * @param {string} [isFeaturedBot] for filter is featured bot 1 or 0
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMainBot: async (limit: number, sort?: string, isOnline?: string, isFeaturedBot?: string, next?: string, prev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getMainBot', 'limit', limit)
            const localVarPath = `/v1/bots/main-bot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (isOnline !== undefined) {
                localVarQueryParameter['is_online'] = isOnline;
            }

            if (isFeaturedBot !== undefined) {
                localVarQueryParameter['is_featured_bot'] = isFeaturedBot;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (prev !== undefined) {
                localVarQueryParameter['prev'] = prev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get main bot details
         * @summary MainBotManagement
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMainBotDetail: async (strCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('getMainBotDetail', 'strCode', strCode)
            const localVarPath = `/v1/bots/main-bot/{strCode}`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MainBotApi - functional programming interface
 * @export
 */
export const MainBotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MainBotApiAxiosParamCreator(configuration)
    return {
        /**
         * get main bots
         * @summary MainBotManagement
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [isOnline] for filter is online bot 1 or 0
         * @param {string} [isFeaturedBot] for filter is featured bot 1 or 0
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMainBot(limit: number, sort?: string, isOnline?: string, isFeaturedBot?: string, next?: string, prev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMainBot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMainBot(limit, sort, isOnline, isFeaturedBot, next, prev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainBotApi.getMainBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get main bot details
         * @summary MainBotManagement
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMainBotDetail(strCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMainBotDetail200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMainBotDetail(strCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainBotApi.getMainBotDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MainBotApi - factory interface
 * @export
 */
export const MainBotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MainBotApiFp(configuration)
    return {
        /**
         * get main bots
         * @summary MainBotManagement
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [isOnline] for filter is online bot 1 or 0
         * @param {string} [isFeaturedBot] for filter is featured bot 1 or 0
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMainBot(limit: number, sort?: string, isOnline?: string, isFeaturedBot?: string, next?: string, prev?: string, options?: any): AxiosPromise<GetMainBot200Response> {
            return localVarFp.getMainBot(limit, sort, isOnline, isFeaturedBot, next, prev, options).then((request) => request(axios, basePath));
        },
        /**
         * get main bot details
         * @summary MainBotManagement
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMainBotDetail(strCode: string, options?: any): AxiosPromise<GetMainBotDetail200Response> {
            return localVarFp.getMainBotDetail(strCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MainBotApi - object-oriented interface
 * @export
 * @class MainBotApi
 * @extends {BaseAPI}
 */
export class MainBotApi extends BaseAPI {
    /**
     * get main bots
     * @summary MainBotManagement
     * @param {number} limit how many items to return at one time (max 100)
     * @param {string} [sort] for sort like desc or asc
     * @param {string} [isOnline] for filter is online bot 1 or 0
     * @param {string} [isFeaturedBot] for filter is featured bot 1 or 0
     * @param {string} [next] parameter next
     * @param {string} [prev] parameter prev
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainBotApi
     */
    public getMainBot(limit: number, sort?: string, isOnline?: string, isFeaturedBot?: string, next?: string, prev?: string, options?: RawAxiosRequestConfig) {
        return MainBotApiFp(this.configuration).getMainBot(limit, sort, isOnline, isFeaturedBot, next, prev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get main bot details
     * @summary MainBotManagement
     * @param {string} strCode code key for all items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainBotApi
     */
    public getMainBotDetail(strCode: string, options?: RawAxiosRequestConfig) {
        return MainBotApiFp(this.configuration).getMainBotDetail(strCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscribeApi - axios parameter creator
 * @export
 */
export const SubscribeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create subscribe plan
         * @summary createSubscribePlan
         * @param {SubscribePlanReq} [subscribePlanReq] create subscribe plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscribePlan: async (subscribePlanReq?: SubscribePlanReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscribe-plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribePlanReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get list subscribe plan
         * @summary getListSubscribePlan
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [botCode] for filter bot_code who have subscribe plan
         * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListSubscribePlan: async (limit: number, sort?: string, orderBy?: string, botCode?: string, isActive?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getListSubscribePlan', 'limit', limit)
            const localVarPath = `/v1/subscribe-plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (botCode !== undefined) {
                localVarQueryParameter['bot_code'] = botCode;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get list user subscription plan
         * @summary getListUserSubscription
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {string} [status] for filter status bot
         * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
         * @param {string} [profileCode] for filter profile_code who have subscribe plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListUserSubscription: async (limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, status?: string, isActive?: string, profileCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getListUserSubscription', 'limit', limit)
            const localVarPath = `/v1/user-subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (prev !== undefined) {
                localVarQueryParameter['prev'] = prev;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (profileCode !== undefined) {
                localVarQueryParameter['profile_code'] = profileCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a subscription plan for a bot
         * @summary Get Subscription Plans
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribePlanDetail: async (strCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('getSubscribePlanDetail', 'strCode', strCode)
            const localVarPath = `/v1/subscribe-plan/{strCode}`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscribeApi - functional programming interface
 * @export
 */
export const SubscribeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscribeApiAxiosParamCreator(configuration)
    return {
        /**
         * create subscribe plan
         * @summary createSubscribePlan
         * @param {SubscribePlanReq} [subscribePlanReq] create subscribe plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscribePlan(subscribePlanReq?: SubscribePlanReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSubscribePlan200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscribePlan(subscribePlanReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscribeApi.createSubscribePlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get list subscribe plan
         * @summary getListSubscribePlan
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [botCode] for filter bot_code who have subscribe plan
         * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListSubscribePlan(limit: number, sort?: string, orderBy?: string, botCode?: string, isActive?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListSubscribePlan200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListSubscribePlan(limit, sort, orderBy, botCode, isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscribeApi.getListSubscribePlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get list user subscription plan
         * @summary getListUserSubscription
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {string} [status] for filter status bot
         * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
         * @param {string} [profileCode] for filter profile_code who have subscribe plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListUserSubscription(limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, status?: string, isActive?: string, profileCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListUserSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListUserSubscription(limit, sort, orderBy, next, prev, status, isActive, profileCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscribeApi.getListUserSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a subscription plan for a bot
         * @summary Get Subscription Plans
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscribePlanDetail(strCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscribePlanDetail200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscribePlanDetail(strCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscribeApi.getSubscribePlanDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscribeApi - factory interface
 * @export
 */
export const SubscribeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscribeApiFp(configuration)
    return {
        /**
         * create subscribe plan
         * @summary createSubscribePlan
         * @param {SubscribePlanReq} [subscribePlanReq] create subscribe plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscribePlan(subscribePlanReq?: SubscribePlanReq, options?: any): AxiosPromise<CreateSubscribePlan200Response> {
            return localVarFp.createSubscribePlan(subscribePlanReq, options).then((request) => request(axios, basePath));
        },
        /**
         * get list subscribe plan
         * @summary getListSubscribePlan
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [botCode] for filter bot_code who have subscribe plan
         * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListSubscribePlan(limit: number, sort?: string, orderBy?: string, botCode?: string, isActive?: string, options?: any): AxiosPromise<GetListSubscribePlan200Response> {
            return localVarFp.getListSubscribePlan(limit, sort, orderBy, botCode, isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * get list user subscription plan
         * @summary getListUserSubscription
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {string} [status] for filter status bot
         * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
         * @param {string} [profileCode] for filter profile_code who have subscribe plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListUserSubscription(limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, status?: string, isActive?: string, profileCode?: string, options?: any): AxiosPromise<GetListUserSubscription200Response> {
            return localVarFp.getListUserSubscription(limit, sort, orderBy, next, prev, status, isActive, profileCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a subscription plan for a bot
         * @summary Get Subscription Plans
         * @param {string} strCode code key for all items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribePlanDetail(strCode: string, options?: any): AxiosPromise<GetSubscribePlanDetail200Response> {
            return localVarFp.getSubscribePlanDetail(strCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscribeApi - object-oriented interface
 * @export
 * @class SubscribeApi
 * @extends {BaseAPI}
 */
export class SubscribeApi extends BaseAPI {
    /**
     * create subscribe plan
     * @summary createSubscribePlan
     * @param {SubscribePlanReq} [subscribePlanReq] create subscribe plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeApi
     */
    public createSubscribePlan(subscribePlanReq?: SubscribePlanReq, options?: RawAxiosRequestConfig) {
        return SubscribeApiFp(this.configuration).createSubscribePlan(subscribePlanReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get list subscribe plan
     * @summary getListSubscribePlan
     * @param {number} limit how many items to return at one time (max 100)
     * @param {string} [sort] for sort like desc or asc
     * @param {string} [orderBy] order data by name or other default latest_msg_at
     * @param {string} [botCode] for filter bot_code who have subscribe plan
     * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeApi
     */
    public getListSubscribePlan(limit: number, sort?: string, orderBy?: string, botCode?: string, isActive?: string, options?: RawAxiosRequestConfig) {
        return SubscribeApiFp(this.configuration).getListSubscribePlan(limit, sort, orderBy, botCode, isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get list user subscription plan
     * @summary getListUserSubscription
     * @param {number} limit how many items to return at one time (max 100)
     * @param {string} [sort] for sort like desc or asc
     * @param {string} [orderBy] order data by name or other default latest_msg_at
     * @param {string} [next] parameter next
     * @param {string} [prev] parameter prev
     * @param {string} [status] for filter status bot
     * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
     * @param {string} [profileCode] for filter profile_code who have subscribe plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeApi
     */
    public getListUserSubscription(limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, status?: string, isActive?: string, profileCode?: string, options?: RawAxiosRequestConfig) {
        return SubscribeApiFp(this.configuration).getListUserSubscription(limit, sort, orderBy, next, prev, status, isActive, profileCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a subscription plan for a bot
     * @summary Get Subscription Plans
     * @param {string} strCode code key for all items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeApi
     */
    public getSubscribePlanDetail(strCode: string, options?: RawAxiosRequestConfig) {
        return SubscribeApiFp(this.configuration).getSubscribePlanDetail(strCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * check user subscription status
         * @summary CheckUserSubscriptionDetail
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserSubscriptionDetail: async (strCode: string, strConvCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('checkUserSubscriptionDetail', 'strCode', strCode)
            // verify required parameter 'strConvCode' is not null or undefined
            assertParamExists('checkUserSubscriptionDetail', 'strConvCode', strConvCode)
            const localVarPath = `/v1/user-subscription/{strConvCode}/bot/{strCode}`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)))
                .replace(`{${"strConvCode"}}`, encodeURIComponent(String(strConvCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a user subscription
         * @summary Create User Subscription
         * @param {CreateUserSubscriptionRequest} createUserSubscriptionRequest Details for the new user subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSubscription: async (createUserSubscriptionRequest: CreateUserSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserSubscriptionRequest' is not null or undefined
            assertParamExists('createUserSubscription', 'createUserSubscriptionRequest', createUserSubscriptionRequest)
            const localVarPath = `/v1/user-subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update is active of a subscription plan for a bot
         * @summary Update Subscription Plan is active
         * @param {string} strCode code key for all items
         * @param {UpdateIsActiveSubscribePlanRequest} [updateIsActiveSubscribePlanRequest] Update subscription plan is active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIsActiveSubscribePlan: async (strCode: string, updateIsActiveSubscribePlanRequest?: UpdateIsActiveSubscribePlanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('updateIsActiveSubscribePlan', 'strCode', strCode)
            const localVarPath = `/v1/subscribe-plan/{strCode}`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateIsActiveSubscribePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update price of subscription plan for a bot
         * @summary Update price Subscription Plan
         * @param {number} intID the id of rosources data
         * @param {UpdatePriceSubscribePlanRequest} [updatePriceSubscribePlanRequest] Update price of subscription plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePriceSubscribePlan: async (intID: number, updatePriceSubscribePlanRequest?: UpdatePriceSubscribePlanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'intID' is not null or undefined
            assertParamExists('updatePriceSubscribePlan', 'intID', intID)
            const localVarPath = `/v1/subscribe-plan/{intID}/price`
                .replace(`{${"intID"}}`, encodeURIComponent(String(intID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePriceSubscribePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a subscription plan for a bot, marking it as successful.
         * @summary Update User Subscription
         * @param {string} strCode code key for all items
         * @param {UpdateUserSubscriptionRequest} updateUserSubscriptionRequest Details for updating the subscription plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSubscription: async (strCode: string, updateUserSubscriptionRequest: UpdateUserSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('updateUserSubscription', 'strCode', strCode)
            // verify required parameter 'updateUserSubscriptionRequest' is not null or undefined
            assertParamExists('updateUserSubscription', 'updateUserSubscriptionRequest', updateUserSubscriptionRequest)
            const localVarPath = `/v1/user-subscription/{strCode}`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * check user subscription status
         * @summary CheckUserSubscriptionDetail
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserSubscriptionDetail(strCode: string, strConvCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckUserSubscriptionDetail200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserSubscriptionDetail(strCode, strConvCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.checkUserSubscriptionDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a user subscription
         * @summary Create User Subscription
         * @param {CreateUserSubscriptionRequest} createUserSubscriptionRequest Details for the new user subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserSubscription(createUserSubscriptionRequest: CreateUserSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserSubscription(createUserSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.createUserSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update is active of a subscription plan for a bot
         * @summary Update Subscription Plan is active
         * @param {string} strCode code key for all items
         * @param {UpdateIsActiveSubscribePlanRequest} [updateIsActiveSubscribePlanRequest] Update subscription plan is active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIsActiveSubscribePlan(strCode: string, updateIsActiveSubscribePlanRequest?: UpdateIsActiveSubscribePlanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register400Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIsActiveSubscribePlan(strCode, updateIsActiveSubscribePlanRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.updateIsActiveSubscribePlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update price of subscription plan for a bot
         * @summary Update price Subscription Plan
         * @param {number} intID the id of rosources data
         * @param {UpdatePriceSubscribePlanRequest} [updatePriceSubscribePlanRequest] Update price of subscription plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePriceSubscribePlan(intID: number, updatePriceSubscribePlanRequest?: UpdatePriceSubscribePlanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register400Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePriceSubscribePlan(intID, updatePriceSubscribePlanRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.updatePriceSubscribePlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of a subscription plan for a bot, marking it as successful.
         * @summary Update User Subscription
         * @param {string} strCode code key for all items
         * @param {UpdateUserSubscriptionRequest} updateUserSubscriptionRequest Details for updating the subscription plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSubscription(strCode: string, updateUserSubscriptionRequest: UpdateUserSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register400Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSubscription(strCode, updateUserSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.updateUserSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * check user subscription status
         * @summary CheckUserSubscriptionDetail
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserSubscriptionDetail(strCode: string, strConvCode: string, options?: any): AxiosPromise<CheckUserSubscriptionDetail200Response> {
            return localVarFp.checkUserSubscriptionDetail(strCode, strConvCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a user subscription
         * @summary Create User Subscription
         * @param {CreateUserSubscriptionRequest} createUserSubscriptionRequest Details for the new user subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSubscription(createUserSubscriptionRequest: CreateUserSubscriptionRequest, options?: any): AxiosPromise<CreateUserSubscription200Response> {
            return localVarFp.createUserSubscription(createUserSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update is active of a subscription plan for a bot
         * @summary Update Subscription Plan is active
         * @param {string} strCode code key for all items
         * @param {UpdateIsActiveSubscribePlanRequest} [updateIsActiveSubscribePlanRequest] Update subscription plan is active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIsActiveSubscribePlan(strCode: string, updateIsActiveSubscribePlanRequest?: UpdateIsActiveSubscribePlanRequest, options?: any): AxiosPromise<Register400Response> {
            return localVarFp.updateIsActiveSubscribePlan(strCode, updateIsActiveSubscribePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update price of subscription plan for a bot
         * @summary Update price Subscription Plan
         * @param {number} intID the id of rosources data
         * @param {UpdatePriceSubscribePlanRequest} [updatePriceSubscribePlanRequest] Update price of subscription plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePriceSubscribePlan(intID: number, updatePriceSubscribePlanRequest?: UpdatePriceSubscribePlanRequest, options?: any): AxiosPromise<Register400Response> {
            return localVarFp.updatePriceSubscribePlan(intID, updatePriceSubscribePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a subscription plan for a bot, marking it as successful.
         * @summary Update User Subscription
         * @param {string} strCode code key for all items
         * @param {UpdateUserSubscriptionRequest} updateUserSubscriptionRequest Details for updating the subscription plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSubscription(strCode: string, updateUserSubscriptionRequest: UpdateUserSubscriptionRequest, options?: any): AxiosPromise<Register400Response> {
            return localVarFp.updateUserSubscription(strCode, updateUserSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * check user subscription status
     * @summary CheckUserSubscriptionDetail
     * @param {string} strCode code key for all items
     * @param {string} strConvCode code key for Conv code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public checkUserSubscriptionDetail(strCode: string, strConvCode: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).checkUserSubscriptionDetail(strCode, strConvCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a user subscription
     * @summary Create User Subscription
     * @param {CreateUserSubscriptionRequest} createUserSubscriptionRequest Details for the new user subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createUserSubscription(createUserSubscriptionRequest: CreateUserSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createUserSubscription(createUserSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update is active of a subscription plan for a bot
     * @summary Update Subscription Plan is active
     * @param {string} strCode code key for all items
     * @param {UpdateIsActiveSubscribePlanRequest} [updateIsActiveSubscribePlanRequest] Update subscription plan is active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public updateIsActiveSubscribePlan(strCode: string, updateIsActiveSubscribePlanRequest?: UpdateIsActiveSubscribePlanRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).updateIsActiveSubscribePlan(strCode, updateIsActiveSubscribePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update price of subscription plan for a bot
     * @summary Update price Subscription Plan
     * @param {number} intID the id of rosources data
     * @param {UpdatePriceSubscribePlanRequest} [updatePriceSubscribePlanRequest] Update price of subscription plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public updatePriceSubscribePlan(intID: number, updatePriceSubscribePlanRequest?: UpdatePriceSubscribePlanRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).updatePriceSubscribePlan(intID, updatePriceSubscribePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a subscription plan for a bot, marking it as successful.
     * @summary Update User Subscription
     * @param {string} strCode code key for all items
     * @param {UpdateUserSubscriptionRequest} updateUserSubscriptionRequest Details for updating the subscription plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public updateUserSubscription(strCode: string, updateUserSubscriptionRequest: UpdateUserSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).updateUserSubscription(strCode, updateUserSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * check user subscription status
         * @summary CheckUserSubscriptionDetail
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserSubscriptionDetail: async (strCode: string, strConvCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strCode' is not null or undefined
            assertParamExists('checkUserSubscriptionDetail', 'strCode', strCode)
            // verify required parameter 'strConvCode' is not null or undefined
            assertParamExists('checkUserSubscriptionDetail', 'strConvCode', strConvCode)
            const localVarPath = `/v1/user-subscription/{strConvCode}/bot/{strCode}`
                .replace(`{${"strCode"}}`, encodeURIComponent(String(strCode)))
                .replace(`{${"strConvCode"}}`, encodeURIComponent(String(strConvCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a user subscription
         * @summary Create User Subscription
         * @param {CreateUserSubscriptionRequest} createUserSubscriptionRequest Details for the new user subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSubscription: async (createUserSubscriptionRequest: CreateUserSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserSubscriptionRequest' is not null or undefined
            assertParamExists('createUserSubscription', 'createUserSubscriptionRequest', createUserSubscriptionRequest)
            const localVarPath = `/v1/user-subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get list user subscription plan
         * @summary getListUserSubscription
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {string} [status] for filter status bot
         * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
         * @param {string} [profileCode] for filter profile_code who have subscribe plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListUserSubscription: async (limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, status?: string, isActive?: string, profileCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getListUserSubscription', 'limit', limit)
            const localVarPath = `/v1/user-subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (prev !== undefined) {
                localVarQueryParameter['prev'] = prev;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (profileCode !== undefined) {
                localVarQueryParameter['profile_code'] = profileCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * check user subscription status
         * @summary CheckUserSubscriptionDetail
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserSubscriptionDetail(strCode: string, strConvCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckUserSubscriptionDetail200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserSubscriptionDetail(strCode, strConvCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.checkUserSubscriptionDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a user subscription
         * @summary Create User Subscription
         * @param {CreateUserSubscriptionRequest} createUserSubscriptionRequest Details for the new user subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserSubscription(createUserSubscriptionRequest: CreateUserSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserSubscription(createUserSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createUserSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get list user subscription plan
         * @summary getListUserSubscription
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {string} [status] for filter status bot
         * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
         * @param {string} [profileCode] for filter profile_code who have subscribe plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListUserSubscription(limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, status?: string, isActive?: string, profileCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListUserSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListUserSubscription(limit, sort, orderBy, next, prev, status, isActive, profileCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getListUserSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * check user subscription status
         * @summary CheckUserSubscriptionDetail
         * @param {string} strCode code key for all items
         * @param {string} strConvCode code key for Conv code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserSubscriptionDetail(strCode: string, strConvCode: string, options?: any): AxiosPromise<CheckUserSubscriptionDetail200Response> {
            return localVarFp.checkUserSubscriptionDetail(strCode, strConvCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a user subscription
         * @summary Create User Subscription
         * @param {CreateUserSubscriptionRequest} createUserSubscriptionRequest Details for the new user subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSubscription(createUserSubscriptionRequest: CreateUserSubscriptionRequest, options?: any): AxiosPromise<CreateUserSubscription200Response> {
            return localVarFp.createUserSubscription(createUserSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * get list user subscription plan
         * @summary getListUserSubscription
         * @param {number} limit how many items to return at one time (max 100)
         * @param {string} [sort] for sort like desc or asc
         * @param {string} [orderBy] order data by name or other default latest_msg_at
         * @param {string} [next] parameter next
         * @param {string} [prev] parameter prev
         * @param {string} [status] for filter status bot
         * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
         * @param {string} [profileCode] for filter profile_code who have subscribe plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListUserSubscription(limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, status?: string, isActive?: string, profileCode?: string, options?: any): AxiosPromise<GetListUserSubscription200Response> {
            return localVarFp.getListUserSubscription(limit, sort, orderBy, next, prev, status, isActive, profileCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * check user subscription status
     * @summary CheckUserSubscriptionDetail
     * @param {string} strCode code key for all items
     * @param {string} strConvCode code key for Conv code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public checkUserSubscriptionDetail(strCode: string, strConvCode: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).checkUserSubscriptionDetail(strCode, strConvCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a user subscription
     * @summary Create User Subscription
     * @param {CreateUserSubscriptionRequest} createUserSubscriptionRequest Details for the new user subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserSubscription(createUserSubscriptionRequest: CreateUserSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createUserSubscription(createUserSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get list user subscription plan
     * @summary getListUserSubscription
     * @param {number} limit how many items to return at one time (max 100)
     * @param {string} [sort] for sort like desc or asc
     * @param {string} [orderBy] order data by name or other default latest_msg_at
     * @param {string} [next] parameter next
     * @param {string} [prev] parameter prev
     * @param {string} [status] for filter status bot
     * @param {string} [isActive] Filter the subscribe plans by their active status. Use &#x60;true&#x60; for active and &#x60;false&#x60; for inactive.
     * @param {string} [profileCode] for filter profile_code who have subscribe plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getListUserSubscription(limit: number, sort?: string, orderBy?: string, next?: string, prev?: string, status?: string, isActive?: string, profileCode?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getListUserSubscription(limit, sort, orderBy, next, prev, status, isActive, profileCode, options).then((request) => request(this.axios, this.basePath));
    }
}



